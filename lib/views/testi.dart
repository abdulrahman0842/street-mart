import 'dart:convert';
import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
// import 'package:geolocator/geolocator.dart';

// class Testi extends StatefulWidget {
//   const Testi({super.key});

//   @override
//   State<Testi> createState() => _TestiState();
// }

// class _TestiState extends State<Testi> {
//   String _currentLocation = "Location not determined";

//   Future<void> _getLocation() async {
//     bool serviceEnabled;
//     LocationPermission permission;

//     serviceEnabled = await Geolocator.isLocationServiceEnabled();
//     if (!serviceEnabled) {
//       setState(() {
//         _currentLocation = "Location service disabled";
//       });
//       return;
//     }
//     permission = await Geolocator.checkPermission();
//     if (permission == LocationPermission.denied) {
//       permission = await Geolocator.requestPermission();
//     }
//     if (permission == LocationPermission.denied) {
//       setState(() {
//         _currentLocation = "Location Permission Denied";
//       });
//       return;
//     }

//     if (permission == LocationPermission.deniedForever) {
//       setState(() {
//         _currentLocation =
//             "Location Permission Denied forever manually grant permission";
//       });
//       return;
//     }

//     //Get Current Posiiton
//     Position position = await Geolocator.getCurrentPosition(
//         desiredAccuracy: LocationAccuracy.high);
//     setState(() {
//       _currentLocation =
//           "Latitude:${position.latitude},Longitude:${position.longitude}";
//     });
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       appBar: AppBar(
//         title: const Text("get Location"),
//       ),
//       // backgroundColor: Colors.black,
//       body: Center(
//         child: Column(
//           mainAxisAlignment: MainAxisAlignment.center,
//           children: [
//             Text(_currentLocation),
//             ElevatedButton(
//                 onPressed: () {
//                   _getLocation();
//                 },
//                 child: const Text("Get Location"))
//           ],
//         ),
//       ),
//     );
//   }
// }

// *********** Fade Transition ***********
// class Testi extends StatefulWidget {
//   const Testi({super.key});

//   @override
//   State<Testi> createState() => _TestiState();
// }

// class _TestiState extends State<Testi> {
//   Route createFadeRoute(Widget page) {
//     return PageRouteBuilder(
//       pageBuilder: (context, animation, secondaryAnimation) => page,
//       transitionsBuilder: (context, animation, secondaryAnimation, child) {
//         return FadeTransition(
//           opacity: animation,
//           child: child,
//         );
//       },
//     );
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//         appBar: AppBar(
//           backgroundColor: Colors.green,
//         ),
//         body: Center(
//             child: // On the first screen
//                 ElevatedButton(
//           onPressed: () {
//             Navigator.of(context).push(createFadeRoute(SecondScreen()));
//           },
//           child: const Text('Go to Second Screen'),
//         )));
//   }
// }

// class SecondScreen extends StatelessWidget {
//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       appBar: AppBar(title: const Text('Second Screen')),
//       body: const Center(child: Text('This is the second screen')),
//     );
//   }
// }

class Autogenerated {
  String? status;
  int? totalResults;
  List<Articles>? articles;

  Autogenerated({this.status, this.totalResults, this.articles});

  Autogenerated.fromJson(Map<String, dynamic> json) {
    status = json['status'];
    totalResults = json['totalResults'];
    if (json['articles'] != null) {
      articles = <Articles>[];
      json['articles'].forEach((v) {
        articles!.add(new Articles.fromJson(v));
      });
    }
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['status'] = status;
    data['totalResults'] = totalResults;
    if (articles != null) {
      data['articles'] = articles!.map((v) => v.toJson()).toList();
    }
    return data;
  }
}

class Articles {
  Source? source;
  String? author;
  String? title;
  String? description;
  String? url;
  String? urlToImage;
  String? publishedAt;
  String? content;

  Articles(
      {this.source,
      this.author,
      this.title,
      this.description,
      this.url,
      this.urlToImage,
      this.publishedAt,
      this.content});

  Articles.fromJson(Map<String, dynamic> json) {
    source =
        json['source'] != null ? new Source.fromJson(json['source']) : null;
    author = json['author'];
    title = json['title'];
    description = json['description'];
    url = json['url'];
    urlToImage = json['urlToImage'];
    publishedAt = json['publishedAt'];
    content = json['content'];
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    if (source != null) {
      data['source'] = source!.toJson();
    }
    data['author'] = author;
    data['title'] = title;
    data['description'] = description;
    data['url'] = url;
    data['urlToImage'] = urlToImage;
    data['publishedAt'] = publishedAt;
    data['content'] = content;
    return data;
  }
}

class Source {
  String? id;
  String? name;

  Source({this.id, this.name});

  Source.fromJson(Map<String, dynamic> json) {
    id = json['id'];
    name = json['name'];
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['id'] = id;
    data['name'] = name;
    return data;
  }
}

class News extends StatefulWidget {
  const News({super.key});

  @override
  State<News> createState() => _NewsState();
}

class _NewsState extends State<News> {
  Future<Autogenerated?> fetcchNews() async {
    final response = await http.get(Uri.parse(
        "https://newsapi.org/v2/everything?q=tesla&from=2024-09-05&sortBy=publishedAt&apiKey=626e0e40c01c4427b5b7a628762b6efa"));

    if (response.statusCode == 200) {
      final json = jsonDecode(response.body);
      final news = Autogenerated.fromJson(json);
      log('called');
      return news;
    } else {
      return null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(),
        body: FutureBuilder(
            future: fetcchNews(),
            builder: (context, snapShot) {
              if (snapShot.hasError) {
                return Text("error");
              }
              if (snapShot.hasData) {
                return ElevatedButton(
                    onPressed: () {
                      Navigator.push(context,
                          MaterialPageRoute(builder: (context) => Hehe()));
                    },
                    child: Text('go'));
              } else {
                return Text('else');
              }
            }));
  }
}

class Hehe extends StatelessWidget {
  const Hehe({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold();
  }
}
